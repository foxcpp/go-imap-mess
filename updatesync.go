package mess

import (
	"strconv"

	"github.com/emersion/go-imap"
)

type UpdateType int

const (
	UpdNewMessage UpdateType = iota
	UpdFlags
	UpdRemoved
	UpdMboxDestroyed
)

type Update struct {
	Type     UpdateType
	Key      interface{}
	SeqSet   string   `json:",omitempty"`
	NewFlags []string `json:",omitempty"`
}

// ExternalUpdate deserializes externally received update and dispatches
// it internal.
func (m *Manager) ExternalUpdate(upd Update) {
	switch upd.Type {
	case UpdNewMessage:
		seq, err := imap.ParseSeqSet(upd.SeqSet)
		if err != nil {
			return
		}

		// We push back the responsibility of storing \Recent flag
		// to the Manager object that generated the update in the first
		// place (we assume it was generated using SetExternalSink).
		//
		// Such Manager will either assign \Recent to one of its local
		// connections or return storeRecent so backend object using this
		// Manager will save the flag.
		m.newMessages(upd.Key, *seq)
	case UpdFlags:
		uid, err := strconv.ParseUint(upd.SeqSet, 10, 32)
		if err != nil {
			return
		}

		m.flagsChanged(upd.Key, uint32(uid), upd.NewFlags)
	case UpdRemoved:
		seq, err := imap.ParseSeqSet(upd.SeqSet)
		if err != nil {
			return
		}

		m.removedSet(upd.Key, *seq)
	case UpdMboxDestroyed:
		m.mailboxDestroyed(upd.Key)
	}
}

// SetExternalSink sets the channel where all updates
// generated by this Manager will be serialized.
//
// Calling this multiple times will replace previosuly set
// channel. Call with nil to disable serialization.
//
// It is not safe to call SetExternalSink concurrently
// with other operations.
func (m *Manager) SetExternalSink(upds chan<- Update) {
	m.sink = upds
}
